# Object model

## Требования:
1. Определите для языка Clojure объектную модель. Обеспечите поддержку следующих элементов:
    * класс;
    * атрибут (свойство, слот);
    * множественное наследование (в предположении что все ветки не пересекаются по атрибутам и методам);
    * диспетчеризацию обработки сообщений относительно одного аргумента (динамический полиморфизм).

2. Определите соответствующие функции и/или макросы для работы с перечисленными выше элементами.

## Дополнительные требования

Выделенные жирным - реализованы

Определите поддержку следующих элементов:
* **множественное наследование;**
* **диспетчеризацию обработки сообщений в иерархии с множественным наследованием (классов или примесей); 
реализуйте аналог call-next-method из CLOS (с фиксированной стратегией диспетчеризации по одному параметру);**
* **включите вспомогательные методы (before, after) в механизм диспетчеризации;**
* обобщенные функции (диспетчеризация по нескольким параметрам);
* **поддержка изменяемого состояния на основе транзакционной памяти (можно использовать встроенную в Clojure 
поддержку STM); обеспечьте реализацию принципа Command-Query Separation на уровне декларации классов 
(и/или других элементов объектной модели).**
* статическая типизация.

## Описание сделанной работы

На данный момент реализованы все базовые требования и 4 дополнительных. Файл с базовой реализацией оставлен для истории

Комментарии по дополнительным требованиям:
* Множественное наследование - не изменилось с базовой реализации, по факту еще в ней было реализованно полноценное 
множественное наследование
* Диспетчеризация и **call-next-method** - диспетчеризация по одному параметру так же была представлена в рамках базовой 
реализации, а **call-next-method** реализован через binding в рекурсивно вызываемой функции, выполняющей входной метод
* **вспомогательные методы (before, after)** - изменен механизм создания метода и его исполнения. Функционал 
и диспатчинг соответствуют CLOS
* **Command-Query Separation и транзакционная память** - это все еще в лекции было расписано

## Описание некоторых моментов

**Иерархия классов:** мы храним иерархию классов в Ref и в самом начале специально вручную
 помещаем класс Object в пустую иерархию классов. Ref изменяется с помощью транзакций
 
**def-class** - почти аналогично лекции, но суперклассы помещаются в список (одноэлементный, если класс один)

**has-field?** - просто рекурсивная проверка, что поле содержится в классе или одном из его суперклассов.
Так как статической типизации пока нет, пересечение полей у классов не является проблемой

**dispatch** - механизм диспетчеризации методов. Обходит иерархию классов, начиная с поданного типа 
и выделяет все подходящие методы из таблицыы виртуальных функций. Подходящие методы разбиваются на 
группы по типу метода (before, after, primary - обычный). Эти группы возвращаются. Если ни один 
primary-метод не найден, бросает ексепшн.

**perform-primary-method** - принимает на вход список primary-методов, функцию, объект и аргументы. 
В начале идет проверка - если список методов пустой, то это ошибка. Иначе делается биндинг для 
call-next-method на функцию perform-primary-method c теми же параметрами, кроме аргументов, только 
вместо списка методов подается его хвост. Далее вызвается функция с головы списка. Таким образом, 
если в вызванной функции будет call-next-method, то он через список методов найдет и исполнит 
следующий метод, обновив при этом функцию call-next-method, чтобы она подходила к возможному 
call-next-method в вызванном методе

**perform-effective-command** - находит через dispatch подходящие методы, разделенные на группы. 
Затем по CLOS сначала выполняются before-методы, затем primary-метод (включая все вызовы 
call-next-method), а после - after-методы. Super удален, так как по принципу действия похож на 
call-next-method и не предусмотрен в CLOS. call-next-method может присутствовать в before- и 
after-методах, но ничего не выполняет (вызывается заглушка с пустой функцией)

**perform-effective-query** - аналогично perform-effective-command, только вызываемая функция не меняет 
состояния объекта и поэтому вызывается не как транзакция

**def-command** - макрос для создания функций. Генерирует код для функции, в котором инициализируется 
 таблица виртуальных функций (Ref) и есть два режима:
 1. Вызов - если первый аргумент объект, то это просто вызов функции и нужно найти и применить подходящую 
 для типа переданного объекта функцию, используя таблицу виртуальных функций
 2. Регистрация - добавляет в таблицу виртуальных функций новую функцию 
 
 Есть проверка, переопределяется ли название функции. То есть, нельзя 2 раза вызвать **def-command**
 с одним названием функции. Но можно несколько раз делать **def-method** с одной комбинацией параметров - 
 возможность переопределить реализацию функции для конкретного класса рассматривалась на лекции как фича

**def-query** - то же, что и предыдущий макрос, но для поиска и вызофа функции используется 
**perform-effective-query**

**def-method** - вызывает код, сгенерированный **def-command** или **def-query** в режиме регистрации
